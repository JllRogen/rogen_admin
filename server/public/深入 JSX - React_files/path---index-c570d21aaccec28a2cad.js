webpackJsonp([0x81b8806e4260],{819:function(e,n){e.exports={data:{code:{edges:[{node:{id:"a-component-using-external-plugins",internal:{contentDigest:'"class MarkdownEditor extends React.Component {\\n  constructor(props) {\\n    super(props);\\n    this.handleChange = this.handleChange.bind(this);\\n    this.state = { value: \'Type some *markdown* here!\' };\\n  }\\n\\n  handleChange(e) {\\n    this.setState({ value: e.target.value });\\n  }\\n\\n  getRawMarkup() {\\n    const md = new Remarkable();\\n    return { __html: md.render(this.state.value) };\\n  }\\n\\n  render() {\\n    return (\\n      <div className=\\"MarkdownEditor\\">\\n        <h3>Input</h3>\\n        <textarea\\n          onChange={this.handleChange}\\n          defaultValue={this.state.value}\\n        />\\n        <h3>Output</h3>\\n        <div\\n          className=\\"content\\"\\n          dangerouslySetInnerHTML={this.getRawMarkup()}\\n        />\\n      </div>\\n    );\\n  }\\n}\\n\\nReactDOM.render(<MarkdownEditor />, mountNode);"'}}},{node:{id:"a-simple-component",internal:{contentDigest:'"class HelloMessage extends React.Component {\\n  render() {\\n    return (\\n      <div>\\n        Hello {this.props.name}\\n      </div>\\n    );\\n  }\\n}\\n\\nReactDOM.render(\\n  <HelloMessage name=\\"Taylor\\" />,\\n  mountNode\\n);"'}}},{node:{id:"a-stateful-component",internal:{contentDigest:'"class Timer extends React.Component {\\n  constructor(props) {\\n    super(props);\\n    this.state = { seconds: 0 };\\n  }\\n\\n  tick() {\\n    this.setState(prevState => ({\\n      seconds: prevState.seconds + 1\\n    }));\\n  }\\n\\n  componentDidMount() {\\n    this.interval = setInterval(() => this.tick(), 1000);\\n  }\\n\\n  componentWillUnmount() {\\n    clearInterval(this.interval);\\n  }\\n\\n  render() {\\n    return (\\n      <div>\\n        Seconds: {this.state.seconds}\\n      </div>\\n    );\\n  }\\n}\\n\\nReactDOM.render(<Timer />, mountNode);"'}}},{node:{id:"an-application",internal:{contentDigest:"\"class TodoApp extends React.Component {\\n  constructor(props) {\\n    super(props);\\n    this.state = { items: [], text: '' };\\n    this.handleChange = this.handleChange.bind(this);\\n    this.handleSubmit = this.handleSubmit.bind(this);\\n  }\\n\\n  render() {\\n    return (\\n      <div>\\n        <h3>TODO</h3>\\n        <TodoList items={this.state.items} />\\n        <form onSubmit={this.handleSubmit}>\\n          <input\\n            onChange={this.handleChange}\\n            value={this.state.text}\\n          />\\n          <button>\\n            Add #{this.state.items.length + 1}\\n          </button>\\n        </form>\\n      </div>\\n    );\\n  }\\n\\n  handleChange(e) {\\n    this.setState({ text: e.target.value });\\n  }\\n\\n  handleSubmit(e) {\\n    e.preventDefault();\\n    if (!this.state.text.length) {\\n      return;\\n    }\\n    const newItem = {\\n      text: this.state.text,\\n      id: Date.now()\\n    };\\n    this.setState(prevState => ({\\n      items: prevState.items.concat(newItem),\\n      text: ''\\n    }));\\n  }\\n}\\n\\nclass TodoList extends React.Component {\\n  render() {\\n    return (\\n      <ul>\\n        {this.props.items.map(item => (\\n          <li key={item.id}>{item.text}</li>\\n        ))}\\n      </ul>\\n    );\\n  }\\n}\\n\\nReactDOM.render(<TodoApp />, mountNode);\""}}}]},examples:{edges:[{node:{fields:{slug:"/home/examples/a-simple-component.html"},frontmatter:{title:"组件"},html:'<p>React 组件使用一个名为 <code>render()</code> 的方法， 接收数据作为输入，输出页面中对应展示的内容。 下面这个示例中类似XML的写法被称为JSX. 输入的数据通过 <code>this.props</code> 传入 <code>render()</code> 方法。</p>\n<p><strong>使用 React 的时候也可以不使用 JSX 语法</strong> 你可以在 <a href="https://babeljs.io/repl/#?presets=react&#x26;code_lz=MYewdgzgLgBApgGzgWzmWBeGAeAFgRgD4AJRBEAGhgHcQAnBAEwEJsB6AwgbgChRJY_KAEMAlmDh0YWRiGABXVOgB0AczhQAokiVQAQgE8AkowAUPGDADkdECChWeASl4AlOMOBQAIgHkAssp0aIySpogoaFBUQmISdC48QA">Babel REPL</a> 查看 JSX 是如何被渲染成原生 JavaScript 代码的。</p>'}},{node:{fields:{slug:"/home/examples/a-stateful-component.html"},frontmatter:{title:"有状态组件"},html:"<p>除了使用外部传入的数据以外 (通过 <code>this.props</code> 访问传入数据), 组件还可以拥有其内部的状态数据 (通过 <code>this.state</code> 访问状态数据)。 当组件的状态数据改变时， 组件会调用 <code>render()</code> 方法重新渲染。</p>"}},{node:{fields:{slug:"/home/examples/an-application.html"},frontmatter:{title:"应用"},html:"<p>使用 <code>props</code> 和 <code>state</code>, 我们可以创建一个简易的 Todo 应用。 下面这个示例中，我们使用 <code>state</code> 来保存现有的待办事项列表及用户的输入。 与此同时，我们也使用了内联的方法添加了事件处理函数，它们将通过事件代理被收集和调用。</p>"}},{node:{fields:{slug:"/home/examples/a-component-using-external-plugins.html"},frontmatter:{title:"在组件中使用第三方库"},html:"<p>React 的使用非常灵活，并且提供了可以调用其他第三方框架或库的接口。下面这个示例就使用了一个用来渲染 markdown 语法，名为 <strong>remarkable</strong> 的库。它可以实时转换渲染 <code>&#x3C;textarea></code> 里的内容。</p>"}}]},marketing:{edges:[{node:{frontmatter:{title:"声明式"},html:"<p>React 可以非常轻松地创建用户交互界面。为你应用的每一个状态设计简洁的视图，在数据改变时 React 也可以高效地更新渲染界面。</p>\n<p>以声明式编写UI，可以让你的代码更加可靠，且方便调试。</p>"}},{node:{frontmatter:{title:"组件化"},html:"<p>创建好拥有各自状态的组件，再由组件构成更加复杂的界面。</p>\n<p>无需再用模版代码，通过使用JavaScript编写的组件你可以更好地传递数据，将应用状态和DOM拆分开来。</p>"}},{node:{frontmatter:{title:"一次学习，随处编写"},html:'<p>无论你现在正在使用什么技术栈，你都可以随时引入 React 开发新特性。</p>\n<p>React 也可以用作开发原生应用的框架 <a href="https://facebook.github.io/react-native/">React Native</a>.</p>'}}]}},pathContext:{}}}});
//# sourceMappingURL=path---index-c570d21aaccec28a2cad.js.map